{"version":3,"file":"components-TextField-TextField-stories.a990ec78.iframe.bundle.js","mappings":";;;AA6BA;;;;;;AAqCA","sources":["webpack://@osuresearch/ripple/./src/components/TextField/TextField.tsx"],"sourcesContent":["import { cx, FormField, Item, Text, Stack, VisuallyHidden } from '@osuresearch/ui';\nimport React, { useRef, useEffect, useState } from 'react';\nimport { Editor, Extensions } from '@tiptap/core';\nimport { useTextField } from 'react-aria';\n\nimport Document from '@tiptap/extension-document';\nimport Paragraph from '@tiptap/extension-paragraph';\nimport TiptapText from '@tiptap/extension-text';\nimport Highlight from '@tiptap/extension-highlight';\nimport Placeholder from '@tiptap/extension-placeholder';\nimport CharacterCount from '@tiptap/extension-character-count';\nimport { NoNewLine } from './NoNewLine';\n\nimport { BaseFieldProps } from '../../react/types';\n\nimport { useEditor, EditorContent } from '@tiptap/react';\nimport StarterKit from '@tiptap/starter-kit';\n// TODO_YJS: import { Collaboration } from './collab';\n// TODO_YJS: import { ydoc, provider as rtcProvider } from '../../yjs';\n// TODO_YJS: import { WebrtcProvider } from 'y-webrtc';\nimport { CharacterLimit } from './CharacterLimit';\nimport styled from 'styled-components';\n\n// TODO_YJS: import './collab-cursor.css';\n\n\nconst Container = styled.div<{ height: number }>`\n  width: 100%;\n  .ProseMirror {\n    min-height: ${(props) => props.height}rem;\n\n    &.ProseMirror-focused {\n      outline: none;\n    }\n  }\n`;\n\n\nexport type TextEditorProps = BaseFieldProps<string> & {\n  limit?: number;\n\n  /**\n   * Initial height of the text container in CSS REM units.\n   * The container will automatically grow in response to\n   * its contents.\n   *\n   * Defaults to `5`.\n   */\n  height?: number;\n\n  /**\n   * Disable newlines. Set to true to mimic simple `<input type=\"text\" />` inputs.\n   *\n   * Do note that text will still wrap in the editor.\n   */\n  noNewline: boolean;\n};\n\n/**\n * The Ripple Text field does not behave exactly like native `input` or `textarea` fields.\n *\n * This supports:\n * - Rich text editing\n * - Markdown WYSIWYG\n * - In-field collaboration and annotation\n */\nexport function TextField({ limit = 0, height = 5, noNewline, ...props }: TextEditorProps) {\n  // TODO_YJS: const [provider, setProvider] = useState<WebrtcProvider>();\n\n  const { name, onChange, onBlur, value, isDisabled } = props;\n\n  useEffect(() => {\n  // TODO_YJS:   setProvider(rtcProvider);\n  }, []);\n\n  // TODO_YJS:\n  // const extensions = provider\n  //   ? [\n  //       // Placeholder.configure({\n  //       //   placeholder: 'Start typing...'\n  //       // }),\n\n  //       StarterKit.configure({\n  //         history: false\n  //       }),\n\n  //       // Collaboration.configure({\n  //       //   document: ydoc,\n  //       //   provider,\n  //       //   field: name + '-tiptap',\n  //       //   user: { color: '#3daee9', name: 'John Doe' }\n  //       // }),\n\n  //       CharacterCount.configure({\n  //         limit\n  //       }),\n  //     ]\n  //   : [Placeholder.configure({ placeholder: 'Loading...' }), StarterKit];\n\n  const extensions = [\n    Placeholder.configure({ placeholder: 'Loading...' }),\n    StarterKit\n  ];\n\n  if (noNewline) {\n    extensions.push(NoNewLine);\n  }\n\n  const editor = useEditor(\n    {\n      content: value,\n      extensions: extensions as Extensions, // TODO: Fix typing.\n      editable: !isDisabled,\n\n      // Sync up when the user types\n      // TODO: Throttle this a bit. Or on the yjs side.\n      onUpdate: ({ editor }) => {\n        if (onChange) {\n          onChange(editor.getHTML());\n        }\n      },\n\n      onBlur({ editor }) {\n        if (onChange) {\n          onChange(editor.getHTML());\n        }\n      },\n\n      editorProps: {\n        attributes: {\n          // Spellcheck breaks when we have remote users highlighting\n          // sections of words, or a word is broken with a comment span.\n          spellcheck: 'false'\n        }\n      },\n    },\n    // TODO_YJS: [provider]\n  );\n\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  const { labelProps, inputProps, descriptionProps, errorMessageProps } = useTextField(props, inputRef);\n\n  return (\n    <FormField<string>\n      labelProps={labelProps}\n      descriptionProps={descriptionProps}\n      errorMessageProps={errorMessageProps}\n      {...props}\n      name={name}\n    >\n      <Container height={height}>\n        <EditorContent editor={editor}\n          id={inputProps.id}\n          aria-labelledby={inputProps['aria-labelledby']}\n          aria-describedby={inputProps['aria-describedby']}\n          className={cx(\n            'rui-w-full rui-p-xs rui-border-2',\n            { 'rui-border-light-shade': !editor?.isFocused },\n            { 'rui-border-dark-shade': editor?.isFocused },\n\n            // { 'rui-border-dimmed rui-bg-light-shade': props.disabled },\n            { 'rui-border-error': inputProps['aria-invalid'] },\n          )}\n          // disabled, readOnly, value, name, onBlur (null), type: text\n        />\n\n        {limit > 0 &&\n          <CharacterLimit limit={limit} count={editor?.storage.characterCount?.characters() ?? 0} />\n        }\n      </Container>\n    </FormField>\n  );\n}\n"],"names":[],"sourceRoot":""}